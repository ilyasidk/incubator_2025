# Flashcards Master

Веб-приложение для создания и изучения флеш-карточек, с возможностью автоматической генерации контента с помощью Google Gemini AI.

## Описание

Flashcards Master - это образовательная платформа, которая помогает пользователям учить новые концепции с помощью интерактивных флеш-карточек. Приложение позволяет создавать собственные наборы карточек по различным темам, изучать их и отслеживать свой прогресс. Уникальной особенностью является возможность генерации карточек с помощью искусственного интеллекта.

Основные возможности:
*   Управление пользователями (регистрация, вход)
*   Создание и управление темами карточек
*   Создание, просмотр, редактирование и удаление карточек
*   Отслеживание прогресса обучения 
*   Генерация карточек с помощью Google Gemini AI на основе заданной темы

## Технологический стек

*   **Бэкенд:** Node.js, Express.js
*   **База данных:** MongoDB (с Mongoose)
*   **Аутентификация:** JSON Web Tokens (JWT) с использованием `bcryptjs` для хеширования паролей
*   **Фронтенд:** HTML, CSS, Ванильный JavaScript
*   **Стилизация:** Tailwind CSS
*   **AI:** Google Generative AI (Gemini) через `@google/generative-ai`
*   **Развертывание:** Docker, GitHub Actions (CI)

### Почему такой стек?

*   **Node.js/Express:** Выбраны за высокую производительность при обработке I/O операций (что важно для веб-сервера), обширную экосистему пакетов (npm), возможность использовать JavaScript на бэкенде и фронтенде, и быструю разработку RESTful API.
*   **MongoDB:** Гибкость NoSQL базы данных хорошо подходит для хранения документов, таких как пользователи, темы и карточки, структура которых может меняться. Mongoose упрощает взаимодействие с БД и валидацию схем.
*   **Ванильный JS/HTML/CSS:** Для текущего объема функциональности фронтенда не требовалась сложная логика управления состоянием или система компонентов, предоставляемая фреймворками (React, Vue, Angular). Это позволило сохранить легковесность фронтенда и избежать дополнительных шагов сборки (кроме Tailwind).
*   **Tailwind CSS:** Утилитарный подход значительно ускоряет разработку пользовательского интерфейса, обеспечивает консистентность стилей и облегчает создание адаптивного дизайна.
*   **Google Gemini AI:** Интеграция с мощной языковой моделью предоставляет уникальную возможность автоматической генерации учебных материалов, повышая ценность приложения.
*   **Docker:** Обеспечивает консистентность среды выполнения между разработкой и продакшеном, упрощает развертывание и изоляцию приложения.
*   **JWT:** Стандартный и безопасный способ реализации аутентификации для API.

## Установка и запуск

### Требования

*   Node.js (версия 18.x, как указано в `Dockerfile` и `ci.yml`)
*   npm
*   MongoDB (локально или удаленно, требуется строка подключения)
*   Docker (опционально, для запуска бэкенда в контейнере)

### Бэкенд

1.  Перейдите в директорию `backend`: `cd backend`
2.  Создайте файл `.env` в корне директории `backend` и добавьте необходимые переменные окружения:
    ```dotenv
    MONGODB_URI=mongodb://your_mongo_uri # Строка подключения к вашей MongoDB
    PORT=8080 # Порт, на котором будет работать бэкенд
    JWT_SECRET=your_jwt_secret_key # Секретный ключ для подписи JWT токенов
    GEMINI_API_KEY=your_google_gemini_api_key # Ключ API для Google Gemini
    NODE_ENV=development # Установите 'production' для продакшн сборки
    ```
3.  Установите зависимости: `npm install` (или `npm ci` для использования `package-lock.json`)
4.  Запустите сервер для разработки (с автоперезагрузкой через `nodemon`): `npm run dev`
    Или запустите сервер для продакшена: `npm start`
5.  (Опционально) Заполните базу данных тестовыми данными (пользователь `test@example.com`/`password123` и примеры тем/карточек): `npm run seed`. **Внимание:** Этот скрипт удаляет существующие данные!

### Фронтенд

1.  Перейдите в директорию `frontend`: `cd frontend`
2.  Установите зависимости разработки: `npm install`
3.  Запустите сервер разработки (`live-server`) и автоматическую компиляцию Tailwind CSS: `npm start`
    Это откроет приложение в браузере (обычно `http://localhost:3000`) и будет отслеживать изменения в файлах `src/input.css` и HTML/JS.

### Docker (Бэкенд)

1.  Убедитесь, что Docker запущен.
2.  Перейдите в директорию `backend`: `cd backend`
3.  Убедитесь, что у вас есть файл `.env` с необходимыми переменными в этой директории.
4.  Соберите Docker образ: `docker build -t flashcards-backend .`
5.  Запустите контейнер: `docker run -p 8080:8080 --env-file .env --name flashcards-app flashcards-backend`

## Процесс проектирования и разработки

Разработка велась итеративно, с фокусом на быстрой реализации основного функционала.

*   **Проектирование API:** Спроектировано по принципам RESTful. Ресурсы (пользователи, темы, карточки, прогресс, генерация) вынесены в отдельные роуты (`backend/routes`). Использовано middleware (`backend/middleware/auth.js`) для защиты роутов с помощью JWT.
*   **Структура базы данных:** Определены Mongoose схемы (`backend/models`) для основных сущностей (`User`, `Topic`, `Card`, `Progress`), отражающие их взаимосвязи (например, карточки и прогресс связаны с пользователем и темой).
*   **Дизайн интерфейса:** Использован Tailwind CSS для быстрой стилизации. Основные страницы - `index.html` (логин/регистрация) и `dashboard.html` (основной интерфейс приложения). Логика интерфейса реализована с помощью ванильного JavaScript (`frontend/script.js`, `frontend/dashboard.js`, `frontend/src/generator.js`).
*   **Реализация:** Бэкенд построен на Express.js, взаимодействие с MongoDB через Mongoose. Фронтенд напрямую взаимодействует с DOM и отправляет запросы к API бэкенда. Настроен базовый CI пайплайн (`.github/workflows/ci.yml`) для проверки установки зависимостей бэкенда.

## Уникальные подходы или методологии

*   **Интеграция с AI:** Ключевой особенностью является использование Google Gemini API (`backend/routes/generate.js`) для автоматической генерации содержания флеш-карточек на основе темы, предоставленной пользователем, что обогащает пользовательский опыт.
*   **Разделение Frontend/Backend:** Четкое разделение на два независимых приложения (`frontend` и `backend`) со взаимодействием через API. Каждое имеет свои зависимости и скрипты запуска.
*   **Контейнеризация:** Использование Docker для бэкенда обеспечивает переносимость и упрощает развертывание.

## Компромиссы

*   **Фронтенд без фреймворка:** Выбор ванильного JavaScript упростил начальную разработку, но может усложнить поддержку и масштабирование интерфейса при значительном росте сложности приложения по сравнению с использованием фреймворков (React, Vue, Angular). Управление состоянием и рендеринг выполняются вручную.
*   **Отсутствие тестов:** В проекте отсутствуют автоматизированные тесты (unit, integration, e2e). Это ускоряет начальную разработку, но повышает риск регрессий при внесении изменений и усложняет рефакторинг. В CI пайплайне шаги для тестов закомментированы.
*   **Базовая обработка ошибок:** Реализован глобальный обработчик ошибок на бэкенде (`backend/server.js`), но он скрывает детали ошибок в продакшене. Обработка ошибок на фронтенде и специфическая обработка на бэкенде могут быть улучшены для более информативной обратной связи.
*   **Базовая конфигурация CORS:** Использована стандартная конфигурация `cors()`. Для продакшен-среды может потребоваться более строгая настройка с указанием разрешенных источников.
*   **Безопасность:** Отсутствие явной валидации входящих данных на API эндпоинтах (кроме той, что может предоставлять Mongoose на уровне схемы). Необходимо добавить строгую валидацию для повышения безопасности.

## Известные ошибки или проблемы / Потенциальные улучшения

*   **Отсутствие тестов:** Необходимо внедрить практику написания тестов (Jest, Mocha/Chai для бэкенда, Jest/Testing Library для фронтенда).
*   **Улучшение обработки ошибок:** Сделать обработку ошибок более детальной как на бэкенде (логирование, возможно, кастомные классы ошибок), так и на фронтенде (отображение понятных сообщений пользователю).
*   **Валидация ввода:** Добавить явную валидацию данных, приходящих на API (например, с помощью `express-validator`).
*   **Усиление безопасности:** Настроить CORS более строго, провести аудит безопасности (например, проверка зависимостей на уязвимости).
*   **Линтинг:** Добавить и настроить линтер (например, ESLint) и форматер (Prettier) и включить их проверку в CI пайплайн.
*   **Масштабируемость фронтенда:** При усложнении интерфейса рассмотреть переход на легковесный фреймворк или библиотеку для управления состоянием.
*   **Оптимизация Dockerfile:** Можно оптимизировать Dockerfile для уменьшения размера образа и ускорения сборки (например, многоэтапная сборка).

## Демо

[Ссылка на ваше видео-демо (Loom, YouTube и т.д.)]

## Лицензия

[Укажите тип лицензии, если есть, например, MIT] 